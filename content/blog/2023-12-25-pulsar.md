+++
title = "<span>Pulsar</span>, a micro creative coding playground"
draft = true

[taxonomies]
category = ["JavaScript"]
tags = ["js", "css", "animation", "canvas"]

[extra]
intro = "Write some JavaScript to create real time animations."
theme = "purple"
image = "/img/pulsar/cover.png"
+++

<link rel="stylesheet" href="/posts/pulsar.css" />

I want to write about a pet project of mine. It is called Pulsar, and it is something I call *a micro creative coding playground*. It allows you to create and share animations using code. Instead of me explaining, please [try playing with it](https://muffinman.io/pulsar/). If it doesn't click right away, consider going through the tutorial.

Here is an example Pulsar animation:

<div class="canvas-wrapper">
<canvas class="canvas canvas-one"></canvas>
</div>

You are presented with a grid of
{{ sidenote(
  text="shapes",
  note="Which I'll call pixels from now on."
) }} and a textbox where you can write a small javascript function to animate the grid.

The function takes four parameters:

* `x` and `y` - coordinates of the pixel
* `t` - time
* `i` - index of the pixel


It needs to return a value between 0 and 1. The function is then evaluated for each pixel in the grid and pixel is animated based on it's return value.

------------

User also has simplex noise available to use.

It supports three different animation modes - scale, opacity and both and user can change between them. There are also three grid modes - classic, which is rectangular grid with circular pixels, hexagonal grid with hexagons and triangular grid with triangles.

It also includes a short tutorial with a few examples to help you get started.

There is a share feature, all properties are encoded to the URL params to allow users to send a link to their friends.

## Implementation

It uses canvas to render animations, but I was initially using SVGs.

### SVG animations

I spent a lot of time making SVG animation work, and I had a bunch of small issues due to a different browser support. In the end, I made it work with CSS translateZ property instead of traditional CSS scale.

#### Jitter in Firefox

The initial structure looked something like this:

```html
<svg>
  <circle />
  <circle />
  <circle />
  ...
</svg>
```

An SVG element with a bunch of circles (or paths) for pixels. I used the animation loop to update CSS scale on each pixel. And it seemed to work fine, but in Firefox elements seemed to jitter a little bit:

<div class="example-wrapper">
  <svg class="svg-jitter svg-wrapper is-in-viewport" viewBox="-75 -75 150 150" data-when-in-viewport="jitterToggle"></svg>

  <video src="/img/pulsar/jitter.mp4#t=0.001" controls loop playsinline style="">
  </video>
</div>

On the left is a live example with the code I was using, while on the right is a video of the jitter, in case you are not using Firefox. It is very subtle jitter, and maybe it doesn't bother you, but I was very annoyed by it. Fixing it ended up being a small journey down a rabbit hole.

It is interesting that it doesn't happen if you use CSS transitions, but only when you manually update scale property in small steps. My guess is that Firefox rounds some values resulting in a circle slightly moving off center.

I tried usual stuff, `translate3d` hack, `will-change`, `backface-visibility`, changing the size of SVG and even more thing I can't remember now. Nothing worked and Firefox kept shaking my pixels.

#### translateZ

At some point, I really don't know how, I came up with an idea of using `translateZ` property to get pixels further away from the eye and therefore scaling them down.

In order for it to work, I had to apply perspective to the elements and to calculate z value based on the scale of the pixel. But it is not a linear function, and after fiddling with it I figured out the formula:

```js
const perspective = 100; // This is arbitrary value I selected
const z = (1 - 1 / pixelScale) * perspective; // Actual code avoids dividing by zero

$pixel.style.transform = `perspective(${perspective}px) translateZ(${z}px)`;
```

As you can see, it is actually an exponential function, and for perspective of 100px, distribution of z values looks like this:

<div class="translate-z-grid">
</div>

#### Blur in Firefox and funky business in Chrome

<div class="example-wrapper">
  <svg class="svg-translate-z-small svg-wrapper is-in-viewport" viewBox="-7.5 -7.5 15.0 15.0" data-when-in-viewport="translateZSmallToggle"></svg>

  <video src="/img/pulsar/ff.mp4#t=0.001" controls loop playsinline style="">
  </video>
</div>

#### Fixed blur, but still funky

<div class="example-wrapper">
  <svg class="svg-translate-z svg-wrapper is-in-viewport" viewBox="-750 -750 1500 1500" data-when-in-viewport="translateZToggle"></svg>

  <video src="/img/pulsar/chrome.mp4#t=0.001" controls loop playsinline style="">
  </video>
</div>

At some point, I want to be able to export animations to gif files. Therefore I rewrote the rendering engine, and now it uses HTML canvas. Once I manage to generate gif files, I'll run these animations on my Pixel Art frame, which I created using a LED Matrix and ESP32.

## Eval is evil

You probably heard the saying "eval is evil". It opens a door for code injection, but because there is no other way to compile user entered code, I had to use it. I had to make sure users couldn't do something "evil", as they can share the URL with others. None of the libraries I tried didn't work for my use case. And after a lot of back and forth, I managed to come up with a system I'm happy about.

I did two main things to prevent any malicious use. The first one was to check for a list of words which might be dangerous. For example `fetch` or `import` which would allow users to download and execute external JavaScript files.

After filtering those, code is evaluated inside of a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) which has it's own, isolated scope. Even if you tried to override some of the built in methods, it wouldn't leak to the global scope.

<form class="form--worker-eval">
<input class="input--worker-eval" value="5 + 10" />
<button class="btn btn--main btn--sm btn--worker-eval">eval</button>
</form>

```js
const worker = new Worker("/js/posts/pulsar-worker.js");

const resolvers = {};

const FORBIDDEN_WORDS = [
  'fetch', 'import', 'XMLHttpRequest'
]

worker.addEventListener("message", (e) => {
  // Find the correct resolver, and resolve the promise
  resolvers[e.data.id](e.data);
  // Remove the resolver reference
  delete resolvers[e.data.id];
});

const lesserOfTwoEvals = async (code) => {
  for (const word of FORBIDDEN_WORDS) {
    if (value.includes(word)) {
      return {
        error: `No usage of "${word}" allowed.`
      };
    }
  }

  return new Promise((resolve) => {
    const id = Date.now().toString() + Math.random().toString();

    resolvers[id] = resolve;

    worker.postMessage({
      id,
      code,
    });
  });
};
```

## Inspiration

* https://www.orillusion.com/en/
* https://tixy.land/
* https://sliderland.blinry.org/

The whole thing is inspired by a project I've seen on the internet years ago. I couldn't find it since and only after I finished Pulsar, I managed to find it again. Pulsar is a little bit different, more colorful and has more features like different grids and animation types.

The whole project brings me a lot of joy and I really hope people will enjoy playing with it.


<script src="/js/posts/pulsar.js"></script>


--------------

## Backup

{{ image(
  src="/img/pulsar/pulsar-screenshot.png",
  alt="Screenshot of Pulsar showing it's UI and animation in paused state",
  link="https://muffinman.io/pulsar/",
  size="md"
) }}

{{ image(
  src="/img/pulsar/pulsar-screenshot.png",
  alt="Screenshot of Pulsar showing it's UI and animation in paused state",
  link="https://muffinman.io/pulsar/",
  size="lg"
) }}
